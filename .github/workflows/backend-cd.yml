name: Backend CD # release 브랜치로 머지된 코드 자동 배포

on:
  push:
    branches: ["release-*"] # release-* 브랜치에 push 될 때만 실행
    paths-ignore:
      - "front/**" # 프론트엔드는 배포에서 제외

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # 1. 깃허브 레포지토리 코드 체크아웃
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Docker Buildx 설정 (멀티 플랫폼 빌드 지원)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # 3. Docker Hub 로그인
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 4. Docker 이미지 빌드 및 Docker Hub에 푸시 (커밋 SHA를 태그로 사용)
      - name: Build and Push Docker Image
        id: build-image
        run: |
          IMAGE=${{ secrets.DOCKER_USERNAME }}/shortorial-be:${{ github.sha }}
          docker buildx build -t $IMAGE --push back/sleep
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

      # 5. AWS OIDC로 인증 (IAM Role과 GitHub 연결)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ap-northeast-2
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubTokenECSRole

      # 6. task-definition-base.json에 이미지와 환경변수 값 치환하여 task-definition.json 생성
      - name: Build ECS task definition with jq
        run: |
          IMAGE=${{ secrets.DOCKER_USERNAME }}/shortorial-be:${{ github.sha }}

          jq --arg img "$IMAGE" \
            --arg AWS_ACCOUNT_ID "${{ secrets.AWS_ACCOUNT_ID }}" \
            --arg MYSQL_URL "${{ secrets.MYSQL_URL }}" \
            --arg MYSQL_USER "${{ secrets.MYSQL_USER }}" \
            --arg MYSQL_PASSWORD "${{ secrets.MYSQL_PASSWORD }}" \
            --arg REDIS_URL "${{ secrets.REDIS_URL }}" \
            --arg JWT_SECRET "${{ secrets.JWT_SECRET }}" \
            --arg ACCESS_KEY "${{ secrets.ACCESS_KEY }}" \
            --arg SECRET_KEY "${{ secrets.SECRET_KEY }}" \
          '
          .executionRoleArn = "arn:aws:iam::\($AWS_ACCOUNT_ID):role/ecsTaskExecutionRole" |
          .containerDefinitions[0].image = $img |
          (.containerDefinitions[0].environment[] | select(.name == "MYSQL_URL")      ).value = $MYSQL_URL |
          (.containerDefinitions[0].environment[] | select(.name == "MYSQL_USER")     ).value = $MYSQL_USER |
          (.containerDefinitions[0].environment[] | select(.name == "MYSQL_PASSWORD") ).value = $MYSQL_PASSWORD |
          (.containerDefinitions[0].environment[] | select(.name == "REDIS_URL")      ).value = $REDIS_URL |
          (.containerDefinitions[0].environment[] | select(.name == "JWT_SECRET")     ).value = $JWT_SECRET |
          (.containerDefinitions[0].environment[] | select(.name == "ACCESS_KEY")     ).value = $ACCESS_KEY |
          (.containerDefinitions[0].environment[] | select(.name == "SECRET_KEY")     ).value = $SECRET_KEY
          ' .aws/task-definition-base.json > task-definition.json

      # 7. ECS에 task 정의 등록
      - name: Register ECS Task Definition
        run: |
          aws ecs register-task-definition \
            --cli-input-json file://task-definition.json

      # 8. ECS 서비스에 최신 revision 반영하여 롤링 배포
      - name: Deploy to Amazon ECS
        run: |
          REVISION=$(aws ecs describe-task-definition \
            --task-definition shortorial-be-task \
            --query "taskDefinition.revision" \
            --output text)

          aws ecs update-service \
            --cluster Shortorial \
            --service shortorial-be-svc \
            --task-definition shortorial-be-task:$REVISION \
            --force-new-deployment
